/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of FFmpeg.xs. Do not edit this file, edit FFmpeg.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "FFmpeg.xs"
#ifdef __cplusplus
"C" {
#endif
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <errno.h>

#include "ffmpeg.h"

/* these are from cmdutils.h, declared here so we don't need to link cmdutils.o */
void show_help_options(const OptionDef *options, const char *msg, int mask, int value){}
void print_error(const char *filename, int err){}
void parse_options(int argc, char **argv, const OptionDef *options){}

/* todo, make av_log() store the error log in a perl-accessible SV* */
/* void av_log(void *avcl, int level, const char *fmt, ...){} */

#line 36 "FFmpeg.c"
XS(XS_FFmpeg_foo); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg_foo)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::foo(self)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 35 "FFmpeg.xs"
	RETVAL = 1234;

#line 50 "FFmpeg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FFmpeg__init_ffmpeg); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__init_ffmpeg)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_init_ffmpeg(self)");
    {
	SV *	self = ST(0);
#line 45 "FFmpeg.xs"
	av_register_all();
#line 66 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__run_ffmpeg); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__run_ffmpeg)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_run_ffmpeg(self)");
    {
	SV *	self = ST(0);
#line 52 "FFmpeg.xs"
	av_encode(output_files, nb_output_files, input_files, nb_input_files, stream_maps, nb_stream_maps);
#line 81 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__cleanup); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__cleanup)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_cleanup(self)");
    {
	SV *	self = ST(0);
#line 66 "FFmpeg.xs"
	nb_input_files  = 0;
	nb_output_files = 0;
	nb_stream_maps  = 0;
#line 98 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_format)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_format(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 76 "FFmpeg.xs"
	opt_format(arg);
#line 114 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_frame_rate); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_frame_rate)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_frame_rate(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 84 "FFmpeg.xs"
    opt_frame_rate(arg);
#line 130 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_frame_size); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_frame_size)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_frame_size(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 92 "FFmpeg.xs"
	opt_frame_size(arg);
#line 146 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_image_format); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_image_format)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_image_format(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 100 "FFmpeg.xs"
	opt_image_format(arg);
#line 162 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_input_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_input_file)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_input_file(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 108 "FFmpeg.xs"
	opt_input_file(arg);
#line 178 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_output_file); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_output_file)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_output_file(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 116 "FFmpeg.xs"
	opt_output_file(arg);
#line 194 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_overwrite); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_overwrite)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_overwrite(self, o)");
    {
	SV *	self = ST(0);
	int	o = (int)SvIV(ST(1));
#line 124 "FFmpeg.xs"
	file_overwrite = o;
#line 210 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_recording_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_recording_time)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_recording_time(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 132 "FFmpeg.xs"
	opt_recording_time(arg);
#line 226 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_start_time); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_start_time)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_start_time(self, arg)");
    {
	SV *	self = ST(0);
	char *	arg = (char *)SvPV_nolen(ST(1));
#line 140 "FFmpeg.xs"
	opt_start_time(arg);
#line 242 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__set_verbose); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__set_verbose)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_set_verbose(self, v)");
    {
	SV *	self = ST(0);
	int	v = (int)SvIV(ST(1));
#line 148 "FFmpeg.xs"
	verbose = v;
#line 258 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__image_formats); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__image_formats)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_image_formats(self)");
    {
	SV *	self = ST(0);
	HV *	RETVAL;
#line 162 "FFmpeg.xs"
	{

	HV *hash = newHV();

	AVInputFormat *ifmt;
	AVOutputFormat *ofmt;
	AVImageFormat *image_fmt;
	URLProtocol *up;
	AVCodec *p, *p2;
	const char **pp, *last_name;

	last_name = "000";

	for (image_fmt = first_image_format; image_fmt != NULL; image_fmt = image_fmt->next) {

		hv_store(
			hash, image_fmt->name, strlen(image_fmt->name), 
			newSVpvf("%s%s", image_fmt->img_read ? "D":" ", 
			image_fmt->img_write ? "E":" "), 0
		);
	}

	RETVAL = hash;

	}

#line 299 "FFmpeg.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_FFmpeg__file_formats); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__file_formats)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_file_formats(self)");
    {
	SV *	self = ST(0);
	HV *	RETVAL;
#line 195 "FFmpeg.xs"
	{

	HV *hash = newHV();

	AVInputFormat *ifmt;
	AVOutputFormat *ofmt;
	AVImageFormat *image_fmt;
	URLProtocol *up;
	AVCodec *p, *p2;
	const char **pp, *last_name;

	// hv_store(hash, "callalert", strlen("callalert"), newSVpv("jkl;",0), 0);

	last_name = "000";

	for(;;) {

		int decode = 0;
		int encode = 0;
		const char *name=NULL;
		const char *longname=NULL;
		const char *mimetype=NULL;

		for (ofmt = first_oformat; ofmt != NULL; ofmt = ofmt->next) {

		if ((name == NULL || strcmp(ofmt->name, name)<0) && strcmp(ofmt->name, last_name)>0) {
			name= ofmt->name;
			longname= ofmt->long_name;
			mimetype= ofmt->mime_type;
			encode=1;
		}

		}

		for (ifmt = first_iformat; ifmt != NULL; ifmt = ifmt->next) {

			if ((name == NULL || strcmp(ifmt->name, name) < 0) && strcmp(ifmt->name, last_name)>0) {
				name= ifmt->name;
				longname= ifmt->long_name;
				encode=0;
			}

			if (name && strcmp(ifmt->name, name) == 0) {
				decode = 1;
			}
		}

		if (name == NULL) {
			break;
		}

		last_name= name;
		HV *codec = newHV();

		hv_store(hash, name, strlen(name), newRV_noinc((SV *) codec), 0);

		hv_store(codec,"capabilities",strlen("capabilities"),
			newSVpvf("%s%s", decode ? "D":" ", encode ? "E":" "),0
		);

		hv_store(codec,"name",strlen("name"), newSVpvf("%s",name),0);
		hv_store(codec,"description",strlen("description"), newSVpvf("%s",longname),0);

		if (mimetype) {
			hv_store(codec,"mime_type",strlen("mime_type"), newSVpvf("%s",mimetype),0);
		}
	}

	RETVAL = hash;
	}

#line 387 "FFmpeg.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_FFmpeg__init_AVFormatContext); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__init_AVFormatContext)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_init_AVFormatContext(self)");
    {
	SV *	self = ST(0);
	int	RETVAL;
	dXSTARG;
#line 274 "FFmpeg.xs"
	RETVAL = (int)av_malloc(sizeof(AVFormatContext));

#line 407 "FFmpeg.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_FFmpeg__free_AVFormatContext); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__free_AVFormatContext)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: FFmpeg::_free_AVFormatContext(self, ic_addr)");
    {
	SV *	self = ST(0);
	int	ic_addr = (int)SvIV(ST(1));
#line 285 "FFmpeg.xs"
	{

	AVFormatContext *ic = (AVFormatContext *) ic_addr;
	av_free(ic);

	}
#line 429 "FFmpeg.c"
    }
    XSRETURN_EMPTY;
}

XS(XS_FFmpeg__init_streamgroup); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__init_streamgroup)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: FFmpeg::_init_streamgroup(self, ic_addr, filename)");
    {
	SV *	self = ST(0);
	int	ic_addr = (int)SvIV(ST(1));
	char *	filename = (char *)SvPV_nolen(ST(2));
	HV *	RETVAL;
#line 299 "FFmpeg.xs"
	{
	HV *hash = newHV();
	HV *stream = newHV();

	hv_store(hash,"stream",strlen("stream"), newRV_noinc((SV *) stream),0);

	AVFormatContext *ic = (AVFormatContext *) ic_addr;
	AVFormatParameters params, *ap = &params;
	int err, i, flags;
	char buf[256];

	ap->image_format = image_format;

	err = av_open_input_file(&ic, filename, file_iformat, 0, ap);

	if (err < 0) {
		hv_store(hash,"error",strlen("error"),newSVpvf("av_open_input_file returned: %d", err),0);
		XSRETURN_UNDEF;
	}

	err = av_find_stream_info(ic);

	if (err < 0) {
		hv_store(
			hash,"error",strlen("error"),
			newSVpvf("av_find_stream_info could not find codec parameters; returned: %d", err),0
		);

		XSRETURN_UNDEF;
	}

	hv_store(hash,"format",strlen("format"), newSVpvf("%s", ic->iformat->name,PL_na), 0);

	hv_store(hash,"url",   strlen("url"), newSVpvf("%s",filename),0);
	hv_store(hash,"title",strlen("title"), newSVpvf("%s",ic->title),0);
	hv_store(hash,"author",strlen("author"), newSVpvf("%s",ic->author),0);
	hv_store(hash,"copyright",strlen("copyright"), newSVpvf("%s",ic->copyright),0);
	hv_store(hash,"comment",strlen("comment"), newSVpvf("%s",ic->comment),0);
	hv_store(hash,"album",strlen("album"), newSVpvf("%s",ic->album),0);
	hv_store(hash,"genre",strlen("genre"), newSVpvf("%s",ic->genre),0);

	hv_store(hash,"year",strlen("year"), newSViv(ic->year),0);
	hv_store(hash,"track",strlen("track"), newSViv(ic->track),0);
	hv_store(hash,"file_size",strlen("file_size"), newSViv(ic->file_size),0);
	hv_store(hash,"data_offset",strlen("data_offset"), newSViv(ic->data_offset),0);

	if (ic->duration != AV_NOPTS_VALUE) {

		int hours, mins, secs, dsecs;
		secs  = ic->duration / AV_TIME_BASE;
		dsecs = ic->duration % AV_TIME_BASE;
		mins  = secs / 60;
		secs %= 60;
		hours = mins / 60;
		mins %= 60;

		/* Time::Piece doesn't like usecs.
		hv_store(hash,"duration",strlen("duration"),
		newSVpvf("%02d:%02d:%02d.%01d", hours, mins, secs, (10 * dsecs) / AV_TIME_BASE),0); */

		hv_store(hash,"duration",strlen("duration"), newSVpvf("%02d:%02d:%02d", hours, mins, secs), 0);
	}

	hv_store(hash,"bit_rate",strlen("bit_rate"), newSViv(ic->bit_rate),0);

	for (i = 0; i < ic->nb_streams; i++) {

		AVStream *st = ic->streams[i];

		HV *tstream = newHV();

		char stream_name[9];
		sprintf(stream_name, "stream%02d", i);

		hv_store(stream,stream_name,strlen(stream_name), newRV_noinc((SV *) tstream),0);

		AVCodecContext *codec = &st->codec;

		/* AVFormatContext values */
		hv_store(tstream,"index",strlen("index"), newSViv(st->index),0);
		hv_store(tstream,"id",strlen("id"), newSViv(st->id),0);
		hv_store(tstream,"real_frame_rate",strlen("real_frame_rate"), newSViv(st->r_frame_rate),0);
		hv_store(tstream,"real_frame_rate_base",strlen("real_frame_rate_base"), newSViv(st->r_frame_rate_base),0);
		hv_store(tstream,"start_time",strlen("start_time"), newSViv(st->start_time),0);
		hv_store(tstream,"duration",strlen("duration"), newSViv(st->duration),0);

		hv_store(tstream,"quality",strlen("quality"), newSVnv(st->quality),0);

		/* AVCodecContext values */
		hv_store(tstream,"bit_rate",strlen("bit_rate"), newSViv(codec->bit_rate),0);
		hv_store(tstream,"bit_rate_tolerance",strlen("bit_rate_tolerance"), newSViv(codec->bit_rate_tolerance),0);
		hv_store(tstream,"frame_rate",strlen("frame_rate"), newSViv(codec->frame_rate),0);
		hv_store(tstream,"width",strlen("width"), newSViv(codec->width),0);
		hv_store(tstream,"height",strlen("height"), newSViv(codec->height),0);
		hv_store(tstream,"sample_rate",strlen("sample_rate"), newSViv(codec->sample_rate),0);
		hv_store(tstream,"channels",strlen("channels"), newSViv(codec->channels),0);
		hv_store(tstream,"sample_format",strlen("sample_format"), newSViv(codec->sample_fmt),0);

		/* do we want to initalize these???
		hv_store(tstream,"frame_size",strlen("frame_size"), newSViv(codec->frame_size),0);
		hv_store(tstream,"frame_number",strlen("frame_number"), newSViv(codec->frame_number),0);
		hv_store(tstream,"real_pict_number",strlen("real_pict_number"), newSViv(codec->real_pict_num),0);

		hv_store(tstream,"codec_name",strlen("codec_name"), newSVpvf("%s",codec->codec_name),0); */

		hv_store(tstream,"codec_id",strlen("codec_id"), newSViv(codec->codec_id),0);
		hv_store(tstream,"codec_tag",strlen("codec_tag"), newSVuv(codec->codec_tag),0);

		/* PixelFormat - initialize?
		hv_store(tstream,"color_table_id",strlen("color_table_id"), newSViv(codec->color_table_id),0); */
	}

	RETVAL = hash;
	}

#line 561 "FFmpeg.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

XS(XS_FFmpeg__codecs); /* prototype to pass -Wmissing-prototypes */
XS(XS_FFmpeg__codecs)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: FFmpeg::_codecs(self)");
    {
	SV *	self = ST(0);
	HV *	RETVAL;
#line 422 "FFmpeg.xs"
	{

	HV *hash = newHV();

	AVInputFormat *ifmt;
	AVOutputFormat *ofmt;
	AVImageFormat *image_fmt;
	URLProtocol *up;
	AVCodec *p, *p2;
	const char **pp, *last_name;

	last_name = "000";

	for (;;) {

		int decode=0;
		int encode=0;
		int cap=0;

		p2 = NULL;

		for (p = first_avcodec; p != NULL; p = p->next) {

			if ((p2==NULL || strcmp(p->name, p2->name)<0) && strcmp(p->name, last_name) > 0) {
				p2= p;
				decode= encode= cap=0;
			}

			if (p2 && strcmp(p->name, p2->name) == 0) {

				if (p->decode) decode = 1;
				if (p->encode) encode = 1;
				cap |= p->capabilities;
			}

		}

		if (p2 == NULL) {
			break;
		}

		last_name= p2->name;

		hv_store(hash, p2->name, strlen(p2->name),
			newSVpvf(
				"[%x]%s%s%s", p2->id, decode ? "D" : " ", 
				encode ? "E" : " ", p2->type == CODEC_TYPE_AUDIO ? "A" : "V"
			), 0
		);
	}

	RETVAL = hash;

	}

#line 633 "FFmpeg.c"
	ST(0) = newRV((SV*)RETVAL);
	sv_2mortal(ST(0));
    }
    XSRETURN(1);
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_FFmpeg); /* prototype to pass -Wmissing-prototypes */
XS(boot_FFmpeg)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

        newXS("FFmpeg::foo", XS_FFmpeg_foo, file);
        newXS("FFmpeg::_init_ffmpeg", XS_FFmpeg__init_ffmpeg, file);
        newXS("FFmpeg::_run_ffmpeg", XS_FFmpeg__run_ffmpeg, file);
        newXS("FFmpeg::_cleanup", XS_FFmpeg__cleanup, file);
        newXS("FFmpeg::_set_format", XS_FFmpeg__set_format, file);
        newXS("FFmpeg::_set_frame_rate", XS_FFmpeg__set_frame_rate, file);
        newXS("FFmpeg::_set_frame_size", XS_FFmpeg__set_frame_size, file);
        newXS("FFmpeg::_set_image_format", XS_FFmpeg__set_image_format, file);
        newXS("FFmpeg::_set_input_file", XS_FFmpeg__set_input_file, file);
        newXS("FFmpeg::_set_output_file", XS_FFmpeg__set_output_file, file);
        newXS("FFmpeg::_set_overwrite", XS_FFmpeg__set_overwrite, file);
        newXS("FFmpeg::_set_recording_time", XS_FFmpeg__set_recording_time, file);
        newXS("FFmpeg::_set_start_time", XS_FFmpeg__set_start_time, file);
        newXS("FFmpeg::_set_verbose", XS_FFmpeg__set_verbose, file);
        newXS("FFmpeg::_image_formats", XS_FFmpeg__image_formats, file);
        newXS("FFmpeg::_file_formats", XS_FFmpeg__file_formats, file);
        newXS("FFmpeg::_init_AVFormatContext", XS_FFmpeg__init_AVFormatContext, file);
        newXS("FFmpeg::_free_AVFormatContext", XS_FFmpeg__free_AVFormatContext, file);
        newXS("FFmpeg::_init_streamgroup", XS_FFmpeg__init_streamgroup, file);
        newXS("FFmpeg::_codecs", XS_FFmpeg__codecs, file);
    XSRETURN_YES;
}

